// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================
// PLANES DE PRECIOS
// ============================================
model Plan {
  id              String   @id @default(cuid())
  name            String              // "Basic", "Pro", "Enterprise"
  price           Float               // 49, 99, 249
  currency        String              @default("USD")

  // Límites del plan
  maxPositions    Int                 @default(1)    // Operaciones simultáneas
  maxBrokers      Int                 @default(1)    // Brokers permitidos
  maxLevels       Int                 @default(3)    // Niveles de promedio

  // Features
  hasTrailingSL   Boolean  @default(true)
  hasAdvancedGrid Boolean  @default(false)
  hasPriority     Boolean  @default(false)  // Soporte prioritario

  stripePriceId   String?  @unique

  tenants         Tenant[]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

// Multi-tenancy: Cada cliente tiene su tenant
model Tenant {
  id              String         @id @default(cuid())
  name            String
  email           String         @unique
  stripeCustomerId String?       @unique
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Plan asignado
  planId          String?
  plan            Plan?          @relation(fields: [planId], references: [id])

  // Telegram notifications
  telegramChatId              String?
  telegramNotificationsEnabled Boolean @default(false)

  users           User[]
  tradingAccounts TradingAccount[]
  signals         Signal[]
  positions       Position[]
  subscriptions   Subscription[]
  backtests       Backtest[]
  simulatedTrades SimulatedTrade[]
  botConfigs      BotConfig[]
  botHeartbeats   BotHeartbeat[]
  signalDeliveries SignalDelivery[]
  securityEvents  SecurityEvent[]
  alerts          Alert[]
}

model User {
  id             String    @id @default(cuid())
  tenantId       String
  tenant         Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  email          String    @unique
  name           String?
  emailVerified  DateTime?
  image          String?
  password       String    // Hashed con bcrypt
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  accounts         Account[]
  sessions         Session[]
  tradingAccounts  TradingAccount[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model TradingAccount {
  id                  String   @id @default(cuid())
  tenantId            String
  tenant              Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId              String?
  user                User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  broker              String              // "VT Markets", "Infinox", etc.
  accountNumber       String
  platform            String              // "MT4", "MT5"
  server              String?
  encryptedApiKey     String              // Encriptado
  encryptedApiSecret  String?             // Encriptado
  isActive            Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  positions           Position[]
}

model Signal {
  id              String   @id @default(cuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Señal original de Telegram
  side            String              // "BUY", "SELL"
  price           Float
  symbol          String              // "XAUUSD"
  messageText     String
  receivedAt     DateTime  @default(now())

  // Estado de procesamiento
  status          String              @default("PENDING") // "PENDING", "EXECUTED", "FAILED", "CANCELLED"
  executedAt      DateTime?

  // Restricciones del canal
  restrictionType String?             // "RIESGO", "SIN_PROMEDIOS", "SOLO_1_PROMEDIO", null
  maxLevels       Int                 @default(4)

  // Resultados
  positions       Position[]
  createdAt       DateTime  @default(now())
}

model Position {
  id              String   @id @default(cuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  signalId        String?
  signal          Signal?  @relation(fields: [signalId], references: [id], onDelete: SetNull)
  tradingAccountId String?
  tradingAccount   TradingAccount? @relation(fields: [tradingAccountId], references: [id], onDelete: SetNull)

  side            String              // "BUY", "SELL"
  symbol          String              // "XAUUSD"
  lotSize         Float
  openPrice       Float
  closePrice      Float?
  stopLoss        Float?
  takeProfit      Float?

  // Estado
  status          String              @default("OPEN") // "OPEN", "CLOSED", "PENDING"
  openedAt        DateTime  @default(now())
  closedAt        DateTime?

  // Resultado
  profitPips      Float?
  profitMoney     Float?

  // Grid levels
  level           Int                 @default(0) // 0=base, 1=primer promedio, etc.

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Subscription {
  id              String   @id @default(cuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  stripePriceId    String?
  stripeSubId      String?   @unique
  status          String              // "ACTIVE", "CANCELED", "PAST_DUE"

  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

// Backtesting System
model Backtest {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name              String?             // Nombre personalizado del backtest
  strategyName      String              // "Toni G4", "Xisco G2", "Custom"
  status            String              @default("PENDING") // "PENDING", "RUNNING", "COMPLETED", "ERROR"

  // Parámetros de configuración (JSON)
  parameters        Json                // { lotaje, pipsDistance, maxLevels, takeProfit, stopLoss, useStopLoss, restrictionType }

  // Resultados
  totalTrades       Int                 @default(0)
  totalProfit       Float               @default(0)
  totalProfitPips   Float               @default(0)
  winRate          Float               @default(0)
  maxDrawdown       Float               @default(0)
  profitFactor      Float               @default(0)

  // Control de ejecución
  startedAt         DateTime?
  completedAt       DateTime?
  error            String?

  // Tiempo de simulación
  ticksProcessed    Int                 @default(0)
  totalTicks        Int                 @default(0)

  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt

  trades           SimulatedTrade[]
}

model SimulatedTrade {
  id              String   @id @default(cuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  backtestId      String
  backtest        Backtest  @relation(fields: [backtestId], references: [id], onDelete: Cascade)

  // Referencia a señal original (si existe)
  signalIndex     Int                 // Índice en el CSV de señales

  // Tipo de evento
  type            String              // "OPEN", "AVERAGE", "CLOSE", "TAKE_PROFIT", "STOP_LOSS"

  // Datos de la operación
  side            String              // "BUY", "SELL"
  price           Float
  lotSize         Float
  level           Int                 @default(0) // 0=base, 1=primer promedio, etc.

  // Resultado
  profit          Float
  profitPips      Float

  // Timestamp de cuándo ocurrió (simulado)
  timestamp       DateTime

  createdAt       DateTime             @default(now())
}

// ============================================
// TICKS CACHE - Datos históricos para backtesting
// ============================================
// Usamos SQLite como cache de disco para evitar cargar ~1GB en memoria.
// Los ticks se importan una vez desde archivos .gz y luego las consultas son rápidas.

model TickData {
  id        Int      @id @default(autoincrement())

  // Símbolo del activo
  symbol    String              // "XAUUSD"

  // Timestamp del tick (almacenado como número para índice eficiente)
  timestamp DateTime            // UTC

  // Precios
  bid       Float
  ask       Float
  spread    Float

  // Índice compuesto para consultas rápidas por rango de fechas
  @@index([symbol, timestamp])
  @@index([timestamp])
}

// ============================================
// BOT SYSTEM - Configuración y Telemetry
// ============================================

/// Configuración del bot por tenant (generada al suscribirse)
model BotConfig {
  id              String   @id @default(cuid())
  tenantId        String   @unique
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // API Key para autenticación del bot
  apiKey          String   @unique    // Hash SHA-256 del API key
  apiKeyPlain     String?             // Solo visible al generar (null después de mostrar)
  apiKeyStatus    String   @default("ACTIVE") // ACTIVE, PAUSED, REVOKED, EXPIRED, GRACE_PERIOD
  apiKeyCreatedAt DateTime @default(now())
  apiKeyExpiresAt DateTime?             // Para rotación programada
  apiKeyRotatedAt DateTime?             // Última rotación

  // Configuración de trading (sobreescrita por plan)
  lotSize         Float    @default(0.01)
  maxLevels       Int      @default(3)
  gridDistance    Float    @default(10.0)    // Pips entre niveles
  takeProfit      Float    @default(20.0)    // Pips de TP

  // Trailing SL
  trailingActivate Float?  // Pips para activar trailing
  trailingStep     Float?  // Pips de paso del trailing
  trailingBack     Float?  // Pips de "back" del trailing

  // Restricciones por defecto
  defaultRestriction String?  // "RIESGO", "SIN_PROMEDIOS", null

  // Paper Trading
  paperTradingMode Boolean  @default(false)  // Si true, no ejecuta ordenes reales

  // Estado
  isActive        Boolean  @default(true)
  lastHeartbeat   DateTime?

  // Rate limiting (reset cada hora)
  requestCount     Int      @default(0)
  rateLimitResetAt DateTime @default(now())

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  auditLogs       ApiKeyAudit[]
}

/// Logs de auditoría para API keys
model ApiKeyAudit {
  id          String   @id @default(cuid())
  botConfigId String
  botConfig   BotConfig @relation(fields: [botConfigId], references: [id], onDelete: Cascade)

  // Evento
  event       String              // API_KEY_GENERATED, API_KEY_REVOKED, API_KEY_ROTATED, API_KEY_ACCESSED, RATE_LIMIT_EXCEEDED
  metadata    Json?               // Datos adicionales del evento

  // Contexto
  ipAddress   String?
  userAgent   String?
  endpoint    String?

  createdAt   DateTime @default(now())

  @@index([botConfigId, createdAt])
  @@index([event, createdAt])
}

/// Eventos de seguridad
model SecurityEvent {
  id          String   @id @default(cuid())
  tenantId    String?
  tenant      Tenant?  @relation(fields: [tenantId], references: [id], onDelete: SetNull)

  // Tipo de evento
  type        String              // SUSPICIOUS_ACTIVITY, BRUTE_FORCE_ATTEMPT, IP_BLOCKED, ABUSE_DETECTED
  severity    String  @default("WARNING") // INFO, WARNING, CRITICAL

  // Detalles
  description String
  metadata    Json?

  // Contexto
  ipAddress   String?
  userAgent   String?
  endpoint    String?

  // Estado
  resolved   Boolean @default(false)
  resolvedAt DateTime?
  resolvedBy String?             // UserId si fue resuelto manualmente

  createdAt   DateTime @default(now())

  @@index([type, createdAt])
  @@index([tenantId, createdAt])
  @@index([resolved, createdAt])
}

/// Heartbeat/Telemetry del bot
model BotHeartbeat {
  id              String   @id @default(cuid())
  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Estado del bot
  status          String              // "RUNNING", "STOPPED", "ERROR", "WAITING_SIGNAL"
  mt5Connected    Boolean  @default(false)
  telegramOk      Boolean  @default(true)  // Siempre true si usa SaaS

  // Posiciones actuales
  openPositions   Int      @default(0)
  currentLevel    Int      @default(0)
  currentSide     String?             // "BUY", "SELL", null

  // Métricas
  totalTrades     Int      @default(0)
  totalProfit     Float    @default(0)

  // Info del sistema
  version         String?
  platform        String?             // "Windows", "Linux"
  error           String?

  receivedAt      DateTime @default(now())

  @@index([tenantId, receivedAt])
}

// ============================================
// SEÑALES GLOBALES - Distribuidas a todos los tenants
// ============================================

/// Señal recibida de Telegram (global, no por tenant)
model GlobalSignal {
  id              String   @id @default(cuid())

  // Tipo de señal
  type            String              // "ENTRY", "CLOSE_RANGE", "SL_MODIFY", "TP_MODIFY"

  // Datos de la señal
  side            String?             // "BUY", "SELL" (null para CLOSE_RANGE)
  price           Float?
  symbol          String              @default("XAUUSD")

  // Restricciones del canal
  restriction     String?             // "RIESGO", "SIN_PROMEDIOS", "SOLO_1_PROMEDIO", null

  // Mensaje original
  messageText     String
  telegramMsgId   Int?                // ID del mensaje en Telegram

  // Estado de distribución
  distributedAt   DateTime?           // Cuándo se distribuyó a los bots

  receivedAt      DateTime @default(now())
  createdAt       DateTime @default(now())

  // Señales entregadas a cada tenant
  deliveries      SignalDelivery[]

  @@index([receivedAt])
  @@index([type, distributedAt])
}

/// Entrega de señal a un tenant específico
model SignalDelivery {
  id              String   @id @default(cuid())

  globalSignalId  String
  globalSignal    GlobalSignal @relation(fields: [globalSignalId], references: [id], onDelete: Cascade)

  tenantId        String
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Estado de la entrega
  status          String   @default("PENDING")  // "PENDING", "DELIVERED", "EXECUTED", "FAILED"
  deliveredAt     DateTime?
  executedAt      DateTime?
  error           String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([globalSignalId, tenantId])
  @@index([tenantId, status])
}

// ============================================
// ALERTAS - Notificaciones para usuarios
// ============================================

/// Alertas del sistema para notificar a usuarios
model Alert {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Tipo de alerta
  type        String              // "BOT_OFFLINE", "BOT_ERROR", "HIGH_DRAWDOWN", "SUBSCRIPTION_EXPIRING"

  // Mensaje y estado
  message     String
  read        Boolean  @default(false)

  // Metadata adicional (opcional)
  metadata    Json?

  createdAt   DateTime @default(now())
  readAt      DateTime?

  @@index([tenantId, read])
  @@index([tenantId, createdAt])
}
